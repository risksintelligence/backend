"""
Sector-Specific Vulnerability Assessment API

Provides endpoints for comprehensive vulnerability analysis tailored to 
different industry sectors with detailed risk profiling and mitigation strategies.
"""

from fastapi import APIRouter, Depends, Query, HTTPException, Path
from datetime import datetime
from typing import Dict, Any, List, Optional

from app.core.security import require_system_rate_limit
from app.services.sector_vulnerability_assessment import (
    get_sector_vulnerability_assessment, 
    IndustrySector, 
    VulnerabilityCategory,
    SeverityLevel
)

router = APIRouter(prefix="/api/v1/vulnerability/sector", tags=["sector-vulnerability"])


@router.get("/assessment/{sector}")
async def get_sector_vulnerability_assessment_endpoint(
    sector: str = Path(..., description="Industry sector to assess"),
    _rate_limit: bool = Depends(require_system_rate_limit),
) -> Dict[str, Any]:
    """Get comprehensive vulnerability assessment for a specific industry sector."""
    try:
        # Validate sector
        try:
            sector_enum = IndustrySector(sector.lower())
        except ValueError:
            available_sectors = [s.value for s in IndustrySector]
            raise HTTPException(
                status_code=400, 
                detail=f"Invalid sector '{sector}'. Available sectors: {available_sectors}"
            )
        
        vulnerability_service = get_sector_vulnerability_assessment()
        assessment = await vulnerability_service.assess_sector_vulnerabilities(sector_enum)
        
        return {
            "assessment": {
                "assessment_id": assessment.assessment_id,
                "sector": assessment.sector.value,
                "sector_name": assessment.sector_profile.sector_name,
                "assessment_date": assessment.assessment_date.isoformat(),
                "overall_risk_score": assessment.overall_risk_score,
                "vulnerability_summary": {
                    "total_vulnerabilities": assessment.vulnerability_count,
                    "critical": assessment.critical_vulnerabilities,
                    "high": assessment.high_vulnerabilities,
                    "medium": assessment.medium_vulnerabilities,
                    "low": assessment.low_vulnerabilities
                },
                "sector_profile": {
                    "complexity_score": assessment.sector_profile.complexity_score,
                    "globalization_index": assessment.sector_profile.globalization_index,
                    "regulatory_burden": assessment.sector_profile.regulatory_burden,
                    "technology_dependency": assessment.sector_profile.technology_dependency,
                    "environmental_sensitivity": assessment.sector_profile.environmental_sensitivity,
                    "geopolitical_exposure": assessment.sector_profile.geopolitical_exposure,
                    "key_suppliers": assessment.sector_profile.key_suppliers,
                    "critical_regions": assessment.sector_profile.critical_regions,
                    "primary_risks": assessment.sector_profile.primary_risks,
                    "seasonal_factors": assessment.sector_profile.seasonal_factors,
                    "compliance_requirements": assessment.sector_profile.compliance_requirements
                },
                "top_vulnerabilities": [
                    {
                        "vulnerability_id": vuln.vulnerability_id,
                        "category": vuln.category.value,
                        "title": vuln.title,
                        "description": vuln.description,
                        "severity": vuln.severity.value,
                        "likelihood": vuln.likelihood,
                        "impact_score": vuln.impact_score,
                        "risk_score": vuln.risk_score,
                        "affected_regions": vuln.affected_regions,
                        "critical_components": vuln.critical_components,
                        "dependencies": vuln.dependencies,
                        "mitigation_strategies": vuln.mitigation_strategies,
                        "time_horizon_days": vuln.time_horizon_days,
                        "confidence_level": vuln.confidence_level,
                        "last_assessed": vuln.last_assessed.isoformat()
                    }
                    for vuln in assessment.top_vulnerabilities
                ],
                "recommendations": assessment.recommendations,
                "next_assessment_date": assessment.next_assessment_date.isoformat()
            },
            "analysis_timestamp": datetime.utcnow().isoformat(),
            "source": "sector_vulnerability_assessment"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to assess sector vulnerabilities: {str(e)}")


@router.get("/comparison")
async def get_sector_comparison(
    sectors: List[str] = Query(..., description="List of industry sectors to compare"),
    _rate_limit: bool = Depends(require_system_rate_limit),
) -> Dict[str, Any]:
    """Compare vulnerability profiles across multiple industry sectors."""
    try:
        # Validate all sectors
        sector_enums = []
        for sector in sectors:
            try:
                sector_enums.append(IndustrySector(sector.lower()))
            except ValueError:
                available_sectors = [s.value for s in IndustrySector]
                raise HTTPException(
                    status_code=400, 
                    detail=f"Invalid sector '{sector}'. Available sectors: {available_sectors}"
                )
        
        if len(sector_enums) < 2:
            raise HTTPException(status_code=400, detail="At least 2 sectors required for comparison")
        
        vulnerability_service = get_sector_vulnerability_assessment()
        comparison = await vulnerability_service.get_sector_comparison(sector_enums)
        
        return {
            "sector_comparison": comparison,
            "analysis_timestamp": datetime.utcnow().isoformat(),
            "source": "sector_comparison_analysis"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to compare sectors: {str(e)}")


@router.get("/cross-sector-impact/{trigger_sector}")
async def get_cross_sector_impact(
    trigger_sector: str = Path(..., description="Sector that triggers the impact analysis"),
    scenario: str = Query("supply_disruption", description="Impact scenario to analyze"),
    _rate_limit: bool = Depends(require_system_rate_limit),
) -> Dict[str, Any]:
    """Analyze potential cross-sector impacts from disruptions in a trigger sector."""
    try:
        # Validate trigger sector
        try:
            trigger_sector_enum = IndustrySector(trigger_sector.lower())
        except ValueError:
            available_sectors = [s.value for s in IndustrySector]
            raise HTTPException(
                status_code=400, 
                detail=f"Invalid sector '{trigger_sector}'. Available sectors: {available_sectors}"
            )
        
        vulnerability_service = get_sector_vulnerability_assessment()
        impacts = await vulnerability_service.assess_cross_sector_impacts(trigger_sector_enum, scenario)
        
        return {
            "cross_sector_analysis": {
                "trigger_sector": trigger_sector,
                "scenario": scenario,
                "total_impacts": len(impacts),
                "impacts": [
                    {
                        "impact_id": impact.impact_id,
                        "source_sector": impact.source_sector.value,
                        "affected_sectors": [s.value for s in impact.affected_sectors],
                        "impact_type": impact.impact_type,
                        "severity": impact.severity.value,
                        "propagation_speed": impact.propagation_speed,
                        "impact_description": impact.impact_description,
                        "mitigation_complexity": impact.mitigation_complexity,
                        "historical_precedents": impact.historical_precedents
                    }
                    for impact in impacts
                ],
                "summary": {
                    "total_affected_sectors": len(set([s.value for impact in impacts for s in impact.affected_sectors])),
                    "critical_impacts": len([i for i in impacts if i.severity.value == "critical"]),
                    "high_impacts": len([i for i in impacts if i.severity.value == "high"]),
                    "immediate_propagation": len([i for i in impacts if i.propagation_speed == "immediate"])
                }
            },
            "analysis_timestamp": datetime.utcnow().isoformat(),
            "source": "cross_sector_impact_analysis"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to analyze cross-sector impacts: {str(e)}")


@router.get("/trends/{sector}")
async def get_vulnerability_trends(
    sector: str = Path(..., description="Industry sector for trend analysis"),
    time_period_days: int = Query(90, ge=30, le=365, description="Time period for trend analysis in days"),
    _rate_limit: bool = Depends(require_system_rate_limit),
) -> Dict[str, Any]:
    """Analyze vulnerability trends for a sector over time."""
    try:
        # Validate sector
        try:
            sector_enum = IndustrySector(sector.lower())
        except ValueError:
            available_sectors = [s.value for s in IndustrySector]
            raise HTTPException(
                status_code=400, 
                detail=f"Invalid sector '{sector}'. Available sectors: {available_sectors}"
            )
        
        vulnerability_service = get_sector_vulnerability_assessment()
        trends = await vulnerability_service.get_vulnerability_trends(sector_enum, time_period_days)
        
        return {
            "vulnerability_trends": trends,
            "analysis_timestamp": datetime.utcnow().isoformat(),
            "source": "vulnerability_trend_analysis"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to analyze vulnerability trends: {str(e)}")


@router.get("/sectors")
async def list_available_sectors(
    _rate_limit: bool = Depends(require_system_rate_limit),
) -> Dict[str, Any]:
    """Get list of available industry sectors for vulnerability assessment."""
    try:
        sectors = []
        for sector in IndustrySector:
            sectors.append({
                "code": sector.value,
                "name": sector.value.replace("_", " ").title(),
                "description": f"{sector.value.replace('_', ' ').title()} industry sector"
            })
        
        return {
            "available_sectors": sectors,
            "total_sectors": len(sectors),
            "vulnerability_categories": [
                {
                    "code": cat.value,
                    "name": cat.value.replace("_", " ").title(),
                    "description": f"{cat.value.replace('_', ' ').title()} vulnerability category"
                }
                for cat in VulnerabilityCategory
            ],
            "severity_levels": [
                {
                    "code": level.value,
                    "name": level.value.title(),
                    "description": f"{level.value.title()} severity level"
                }
                for level in SeverityLevel
            ],
            "analysis_timestamp": datetime.utcnow().isoformat(),
            "source": "sector_vulnerability_metadata"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to list sectors: {str(e)}")


@router.get("/summary")
async def get_vulnerability_summary(
    _rate_limit: bool = Depends(require_system_rate_limit),
) -> Dict[str, Any]:
    """Get high-level vulnerability summary across all sectors."""
    try:
        vulnerability_service = get_sector_vulnerability_assessment()
        
        # Get assessments for key sectors
        key_sectors = [
            IndustrySector.TECHNOLOGY,
            IndustrySector.AUTOMOTIVE,
            IndustrySector.HEALTHCARE,
            IndustrySector.ENERGY
        ]
        
        sector_summaries = []
        total_critical = 0
        total_high = 0
        total_vulnerabilities = 0
        
        for sector in key_sectors:
            assessment = await vulnerability_service.assess_sector_vulnerabilities(sector)
            
            sector_summary = {
                "sector": sector.value,
                "sector_name": assessment.sector_profile.sector_name,
                "overall_risk_score": assessment.overall_risk_score,
                "critical_vulnerabilities": assessment.critical_vulnerabilities,
                "high_vulnerabilities": assessment.high_vulnerabilities,
                "total_vulnerabilities": assessment.vulnerability_count,
                "top_risk": assessment.top_vulnerabilities[0].title if assessment.top_vulnerabilities else "None"
            }
            
            sector_summaries.append(sector_summary)
            total_critical += assessment.critical_vulnerabilities
            total_high += assessment.high_vulnerabilities
            total_vulnerabilities += assessment.vulnerability_count
        
        # Calculate overall statistics
        avg_risk_score = sum([s["overall_risk_score"] for s in sector_summaries]) / len(sector_summaries)
        highest_risk_sector = max(sector_summaries, key=lambda x: x["overall_risk_score"])
        
        return {
            "vulnerability_summary": {
                "total_sectors_analyzed": len(key_sectors),
                "total_vulnerabilities": total_vulnerabilities,
                "total_critical_vulnerabilities": total_critical,
                "total_high_vulnerabilities": total_high,
                "average_risk_score": round(avg_risk_score, 2),
                "highest_risk_sector": highest_risk_sector,
                "sector_details": sector_summaries,
                "global_trends": {
                    "increasing_complexity": True,
                    "geopolitical_tensions": "high",
                    "cyber_threats": "increasing",
                    "supply_chain_brittleness": "high"
                },
                "recommendations": [
                    "Prioritize critical vulnerability remediation across all sectors",
                    "Enhance cross-sector coordination for systemic risk management",
                    "Implement sector-specific resilience frameworks",
                    "Develop early warning systems for cascade effects"
                ]
            },
            "analysis_timestamp": datetime.utcnow().isoformat(),
            "source": "global_vulnerability_summary"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to generate vulnerability summary: {str(e)}")