"""
Sector-Specific Vulnerability Assessment Tools

Provides comprehensive vulnerability analysis tailored to different industry sectors,
incorporating sector-specific risk factors, critical dependencies, and vulnerability patterns.
"""

import logging
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
import hashlib

from ..core.unified_cache import UnifiedCache
from ..core.config import get_settings

logger = logging.getLogger(__name__)


class IndustrySector(Enum):
    TECHNOLOGY = "technology"
    AUTOMOTIVE = "automotive"
    HEALTHCARE = "healthcare"
    ENERGY = "energy"
    MATERIALS = "materials"
    INDUSTRIALS = "industrials"
    CONSUMER_DISCRETIONARY = "consumer_discretionary"
    CONSUMER_STAPLES = "consumer_staples"
    FINANCIAL_SERVICES = "financial_services"
    TELECOMMUNICATIONS = "telecommunications"
    UTILITIES = "utilities"
    AEROSPACE_DEFENSE = "aerospace_defense"


class VulnerabilityCategory(Enum):
    SUPPLY_CHAIN = "supply_chain"
    GEOPOLITICAL = "geopolitical"
    REGULATORY = "regulatory"
    TECHNOLOGICAL = "technological"
    ENVIRONMENTAL = "environmental"
    FINANCIAL = "financial"
    CYBER_SECURITY = "cyber_security"
    OPERATIONAL = "operational"


class SeverityLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class SectorVulnerability:
    vulnerability_id: str
    sector: IndustrySector
    category: VulnerabilityCategory
    title: str
    description: str
    severity: SeverityLevel
    likelihood: float  # 0-100
    impact_score: float  # 0-100
    risk_score: float  # Calculated: (likelihood * impact_score) / 100
    affected_regions: List[str]
    critical_components: List[str]
    dependencies: List[str]
    mitigation_strategies: List[str]
    time_horizon_days: int
    confidence_level: float  # 0-100
    last_assessed: datetime


@dataclass
class SectorProfile:
    sector: IndustrySector
    sector_name: str
    complexity_score: float  # 0-100
    globalization_index: float  # 0-100
    regulatory_burden: float  # 0-100
    technology_dependency: float  # 0-100
    environmental_sensitivity: float  # 0-100
    geopolitical_exposure: float  # 0-100
    key_suppliers: List[str]
    critical_regions: List[str]
    primary_risks: List[str]
    seasonal_factors: List[str]
    compliance_requirements: List[str]


@dataclass
class VulnerabilityAssessment:
    assessment_id: str
    sector: IndustrySector
    assessment_date: datetime
    overall_risk_score: float  # 0-100
    vulnerability_count: int
    critical_vulnerabilities: int
    high_vulnerabilities: int
    medium_vulnerabilities: int
    low_vulnerabilities: int
    top_vulnerabilities: List[SectorVulnerability]
    sector_profile: SectorProfile
    recommendations: List[str]
    next_assessment_date: datetime


@dataclass
class CrossSectorImpact:
    impact_id: str
    source_sector: IndustrySector
    affected_sectors: List[IndustrySector]
    impact_type: str
    severity: SeverityLevel
    propagation_speed: str  # "immediate", "hours", "days", "weeks"
    impact_description: str
    mitigation_complexity: str  # "low", "medium", "high"
    historical_precedents: List[str]


class SectorVulnerabilityAssessment:
    """
    Comprehensive sector-specific vulnerability assessment service.
    
    Provides tailored vulnerability analysis for different industry sectors,
    incorporating sector-specific risk factors, dependencies, and mitigation strategies.
    """
    
    def __init__(self):
        self.cache = UnifiedCache("sector_vulnerability")
        self.settings = get_settings()
        
        # Initialize sector-specific profiles
        self.sector_profiles = self._initialize_sector_profiles()
        
        # Vulnerability assessment templates by sector
        self.vulnerability_templates = self._initialize_vulnerability_templates()
        
        # Cross-sector impact matrices
        self.cross_sector_impacts = self._initialize_cross_sector_impacts()


    async def assess_sector_vulnerabilities(self, sector: IndustrySector) -> VulnerabilityAssessment:
        """Perform comprehensive vulnerability assessment for a specific sector."""
        cache_key = f"sector_assessment_{sector.value}"
        
        cached_data, metadata = self.cache.get(cache_key)
        if cached_data and not (metadata and metadata.is_stale_soft):
            # Reconstruct from cached data
            cached_data['sector'] = IndustrySector(cached_data['sector'])
            cached_data['assessment_date'] = datetime.fromisoformat(cached_data['assessment_date'])
            cached_data['next_assessment_date'] = datetime.fromisoformat(cached_data['next_assessment_date'])
            
            # Reconstruct vulnerabilities
            vulnerabilities = []
            for vuln_data in cached_data['top_vulnerabilities']:
                vuln_data['sector'] = IndustrySector(vuln_data['sector'])
                vuln_data['category'] = VulnerabilityCategory(vuln_data['category'])
                vuln_data['severity'] = SeverityLevel(vuln_data['severity'])
                vuln_data['last_assessed'] = datetime.fromisoformat(vuln_data['last_assessed'])
                vulnerabilities.append(SectorVulnerability(**vuln_data))
            cached_data['top_vulnerabilities'] = vulnerabilities
            
            # Reconstruct sector profile
            profile_data = cached_data['sector_profile']
            profile_data['sector'] = IndustrySector(profile_data['sector'])
            cached_data['sector_profile'] = SectorProfile(**profile_data)
            
            return VulnerabilityAssessment(**cached_data)
        
        # Generate fresh assessment
        assessment = await self._generate_sector_assessment(sector)
        
        # Cache the results
        serializable_data = self._serialize_assessment(assessment)
        self.cache.set(
            cache_key,
            serializable_data,
            source="SECTOR_VULNERABILITY_ANALYSIS",
            source_url=f"/sector-assessment/{sector.value}",
            soft_ttl=14400  # 4 hours
        )
        
        return assessment


    async def get_sector_comparison(self, sectors: List[IndustrySector]) -> Dict[str, Any]:
        """Compare vulnerability profiles across multiple sectors."""
        cache_key = f"sector_comparison_{hashlib.md5('_'.join(sorted([s.value for s in sectors])).encode()).hexdigest()}"
        
        cached_data, metadata = self.cache.get(cache_key)
        if cached_data and not (metadata and metadata.is_stale_soft):
            return cached_data
        
        # Get assessments for all sectors
        assessments = {}
        for sector in sectors:
            assessment = await self.assess_sector_vulnerabilities(sector)
            assessments[sector.value] = assessment
        
        # Generate comparison analysis
        comparison = self._generate_sector_comparison(assessments)
        
        # Cache the comparison
        self.cache.set(
            cache_key,
            comparison,
            source="SECTOR_COMPARISON_ANALYSIS",
            source_url="/sector-comparison",
            soft_ttl=21600  # 6 hours
        )
        
        return comparison


    async def assess_cross_sector_impacts(self, trigger_sector: IndustrySector, 
                                        scenario: str = "supply_disruption") -> List[CrossSectorImpact]:
        """Analyze potential cross-sector impacts from disruptions in trigger sector."""
        cache_key = f"cross_sector_impact_{trigger_sector.value}_{scenario}"
        
        cached_data, metadata = self.cache.get(cache_key)
        if cached_data and not (metadata and metadata.is_stale_soft):
            # Reconstruct impacts from cached data
            impacts = []
            for impact_data in cached_data:
                impact_data['source_sector'] = IndustrySector(impact_data['source_sector'])
                impact_data['affected_sectors'] = [IndustrySector(s) for s in impact_data['affected_sectors']]
                impact_data['severity'] = SeverityLevel(impact_data['severity'])
                impacts.append(CrossSectorImpact(**impact_data))
            return impacts
        
        # Generate cross-sector impact analysis
        impacts = await self._analyze_cross_sector_impacts(trigger_sector, scenario)
        
        # Cache the results
        serializable_data = []
        for impact in impacts:
            impact_dict = asdict(impact)
            impact_dict['source_sector'] = impact.source_sector.value
            impact_dict['affected_sectors'] = [s.value for s in impact.affected_sectors]
            impact_dict['severity'] = impact.severity.value
            serializable_data.append(impact_dict)
        
        self.cache.set(
            cache_key,
            serializable_data,
            source="CROSS_SECTOR_IMPACT_ANALYSIS",
            source_url=f"/cross-sector-impact/{trigger_sector.value}",
            soft_ttl=10800  # 3 hours
        )
        
        return impacts


    async def get_vulnerability_trends(self, sector: IndustrySector, 
                                     time_period_days: int = 90) -> Dict[str, Any]:
        """Analyze vulnerability trends for a sector over time."""
        cache_key = f"vulnerability_trends_{sector.value}_{time_period_days}"
        
        cached_data, metadata = self.cache.get(cache_key)
        if cached_data and not (metadata and metadata.is_stale_soft):
            return cached_data
        
        # Generate vulnerability trend analysis
        trends = await self._analyze_vulnerability_trends(sector, time_period_days)
        
        # Cache the trends
        self.cache.set(
            cache_key,
            trends,
            source="VULNERABILITY_TREND_ANALYSIS",
            source_url=f"/vulnerability-trends/{sector.value}",
            soft_ttl=43200  # 12 hours
        )
        
        return trends


    def _initialize_sector_profiles(self) -> Dict[IndustrySector, SectorProfile]:
        """Initialize comprehensive sector profiles with characteristics and dependencies."""
        profiles = {}
        
        profiles[IndustrySector.TECHNOLOGY] = SectorProfile(
            sector=IndustrySector.TECHNOLOGY,
            sector_name="Technology",
            complexity_score=95,
            globalization_index=90,
            regulatory_burden=60,
            technology_dependency=100,
            environmental_sensitivity=30,
            geopolitical_exposure=85,
            key_suppliers=["TSMC", "Samsung", "ASML", "Applied Materials", "Foxconn"],
            critical_regions=["Taiwan", "South Korea", "China", "Netherlands", "Japan"],
            primary_risks=["Semiconductor shortages", "IP theft", "Trade restrictions", "Cyber attacks"],
            seasonal_factors=["Consumer electronics cycles", "Enterprise refresh cycles"],
            compliance_requirements=["GDPR", "CCPA", "Export controls", "Cybersecurity frameworks"]
        )
        
        profiles[IndustrySector.AUTOMOTIVE] = SectorProfile(
            sector=IndustrySector.AUTOMOTIVE,
            sector_name="Automotive",
            complexity_score=88,
            globalization_index=95,
            regulatory_burden=85,
            technology_dependency=75,
            environmental_sensitivity=70,
            geopolitical_exposure=80,
            key_suppliers=["Bosch", "Continental", "Denso", "Magna", "ZF Friedrichshafen"],
            critical_regions=["Germany", "Japan", "China", "Mexico", "South Korea"],
            primary_risks=["Chip shortages", "Raw material costs", "EV transition", "Trade tensions"],
            seasonal_factors=["Model year cycles", "Weather impacts"],
            compliance_requirements=["EPA emissions", "NHTSA safety", "EU regulations", "China NEV policy"]
        )
        
        profiles[IndustrySector.HEALTHCARE] = SectorProfile(
            sector=IndustrySector.HEALTHCARE,
            sector_name="Healthcare",
            complexity_score=85,
            globalization_index=70,
            regulatory_burden=100,
            technology_dependency=65,
            environmental_sensitivity=40,
            geopolitical_exposure=60,
            key_suppliers=["Johnson & Johnson", "Pfizer", "Roche", "Medtronic", "Abbott"],
            critical_regions=["USA", "Switzerland", "Germany", "India", "China"],
            primary_risks=["Regulatory changes", "Patent cliffs", "Supply shortages", "Quality issues"],
            seasonal_factors=["Flu seasons", "Pandemic cycles"],
            compliance_requirements=["FDA approvals", "GMP standards", "Clinical trials", "Privacy laws"]
        )
        
        profiles[IndustrySector.ENERGY] = SectorProfile(
            sector=IndustrySector.ENERGY,
            sector_name="Energy",
            complexity_score=80,
            globalization_index=85,
            regulatory_burden=90,
            technology_dependency=55,
            environmental_sensitivity=100,
            geopolitical_exposure=95,
            key_suppliers=["Saudi Aramco", "ExxonMobil", "Shell", "BP", "Chevron"],
            critical_regions=["Middle East", "Russia", "USA", "Norway", "Venezuela"],
            primary_risks=["Geopolitical tensions", "Price volatility", "Climate regulations", "Infrastructure attacks"],
            seasonal_factors=["Heating seasons", "Hurricane seasons", "Maintenance cycles"],
            compliance_requirements=["Environmental regulations", "Safety standards", "Export controls"]
        )
        
        # Add more sector profiles as needed...
        return profiles


    def _initialize_vulnerability_templates(self) -> Dict[IndustrySector, List[Dict[str, Any]]]:
        """Initialize vulnerability assessment templates for each sector."""
        templates = {}
        
        templates[IndustrySector.TECHNOLOGY] = [
            {
                "category": VulnerabilityCategory.SUPPLY_CHAIN,
                "title": "Semiconductor Dependency",
                "description": "Critical dependence on limited semiconductor fabs in geopolitically sensitive regions",
                "base_severity": SeverityLevel.CRITICAL,
                "base_likelihood": 70,
                "base_impact": 90,
                "affected_regions": ["Taiwan", "South Korea", "China"],
                "critical_components": ["Advanced processors", "Memory chips", "Power management ICs"]
            },
            {
                "category": VulnerabilityCategory.CYBER_SECURITY,
                "title": "Supply Chain Cyber Attacks",
                "description": "Vulnerabilities in software supply chain and third-party components",
                "base_severity": SeverityLevel.HIGH,
                "base_likelihood": 85,
                "base_impact": 75,
                "affected_regions": ["Global"],
                "critical_components": ["Open source libraries", "Third-party APIs", "Cloud services"]
            },
            {
                "category": VulnerabilityCategory.GEOPOLITICAL,
                "title": "Trade Restrictions",
                "description": "Export controls and technology transfer restrictions affecting key components",
                "base_severity": SeverityLevel.HIGH,
                "base_likelihood": 60,
                "base_impact": 85,
                "affected_regions": ["China", "Russia", "Iran"],
                "critical_components": ["Advanced semiconductors", "AI chips", "Quantum technologies"]
            }
        ]
        
        templates[IndustrySector.AUTOMOTIVE] = [
            {
                "category": VulnerabilityCategory.SUPPLY_CHAIN,
                "title": "Microcontroller Shortages",
                "description": "Automotive-grade chip shortages affecting production capacity",
                "base_severity": SeverityLevel.HIGH,
                "base_likelihood": 80,
                "base_impact": 85,
                "affected_regions": ["Taiwan", "Japan", "Germany"],
                "critical_components": ["MCUs", "Power semiconductors", "Sensors"]
            },
            {
                "category": VulnerabilityCategory.TECHNOLOGICAL,
                "title": "EV Transition Risks",
                "description": "Supply chain disruptions from rapid shift to electric vehicles",
                "base_severity": SeverityLevel.MEDIUM,
                "base_likelihood": 75,
                "base_impact": 70,
                "affected_regions": ["China", "Europe", "USA"],
                "critical_components": ["Lithium batteries", "Rare earth minerals", "Charging infrastructure"]
            },
            {
                "category": VulnerabilityCategory.ENVIRONMENTAL,
                "title": "Raw Material Constraints",
                "description": "Limited access to critical minerals for batteries and electronics",
                "base_severity": SeverityLevel.HIGH,
                "base_likelihood": 65,
                "base_impact": 80,
                "affected_regions": ["Congo", "Chile", "Australia", "China"],
                "critical_components": ["Lithium", "Cobalt", "Nickel", "Rare earth elements"]
            }
        ]
        
        # Add more sector templates as needed...
        return templates


    def _initialize_cross_sector_impacts(self) -> List[CrossSectorImpact]:
        """Initialize cross-sector impact relationships."""
        impacts = []
        
        # Technology sector impacts
        impacts.append(CrossSectorImpact(
            impact_id="tech_to_auto",
            source_sector=IndustrySector.TECHNOLOGY,
            affected_sectors=[IndustrySector.AUTOMOTIVE, IndustrySector.INDUSTRIALS],
            impact_type="semiconductor_shortage",
            severity=SeverityLevel.CRITICAL,
            propagation_speed="days",
            impact_description="Semiconductor shortages cascade to automotive and industrial production",
            mitigation_complexity="high",
            historical_precedents=["2020-2022 chip shortage", "2011 Japan earthquake impacts"]
        ))
        
        # Energy sector impacts
        impacts.append(CrossSectorImpact(
            impact_id="energy_to_all",
            source_sector=IndustrySector.ENERGY,
            affected_sectors=[s for s in IndustrySector if s != IndustrySector.ENERGY],
            impact_type="energy_crisis",
            severity=SeverityLevel.CRITICAL,
            propagation_speed="immediate",
            impact_description="Energy supply disruptions affect all sectors through increased costs and shortages",
            mitigation_complexity="high",
            historical_precedents=["1973 oil crisis", "2022 Europe energy crisis", "Texas freeze 2021"]
        ))
        
        # Healthcare sector impacts
        impacts.append(CrossSectorImpact(
            impact_id="health_to_consumer",
            source_sector=IndustrySector.HEALTHCARE,
            affected_sectors=[IndustrySector.CONSUMER_STAPLES, IndustrySector.CONSUMER_DISCRETIONARY],
            impact_type="pandemic_response",
            severity=SeverityLevel.HIGH,
            propagation_speed="weeks",
            impact_description="Healthcare crises drive changes in consumer behavior and demand patterns",
            mitigation_complexity="medium",
            historical_precedents=["COVID-19 pandemic", "SARS outbreak", "H1N1 pandemic"]
        ))
        
        return impacts


    async def _generate_sector_assessment(self, sector: IndustrySector) -> VulnerabilityAssessment:
        """Generate a comprehensive vulnerability assessment for the specified sector."""
        assessment_id = f"SA_{sector.value}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        assessment_date = datetime.utcnow()
        
        # Get sector profile
        sector_profile = self.sector_profiles.get(sector)
        if not sector_profile:
            raise ValueError(f"Sector profile not found for {sector.value}")
        
        # Generate vulnerabilities based on templates
        vulnerabilities = []
        vulnerability_templates = self.vulnerability_templates.get(sector, [])
        
        for i, template in enumerate(vulnerability_templates[:10]):  # Limit to top 10
            vulnerability = self._create_vulnerability_from_template(sector, template, i)
            vulnerabilities.append(vulnerability)
        
        # Calculate summary statistics
        total_vulnerabilities = len(vulnerabilities)
        critical_count = len([v for v in vulnerabilities if v.severity == SeverityLevel.CRITICAL])
        high_count = len([v for v in vulnerabilities if v.severity == SeverityLevel.HIGH])
        medium_count = len([v for v in vulnerabilities if v.severity == SeverityLevel.MEDIUM])
        low_count = len([v for v in vulnerabilities if v.severity == SeverityLevel.LOW])
        
        # Calculate overall risk score
        total_risk = sum([v.risk_score for v in vulnerabilities])
        overall_risk_score = total_risk / len(vulnerabilities) if vulnerabilities else 0
        
        # Generate recommendations
        recommendations = self._generate_sector_recommendations(sector, vulnerabilities)
        
        return VulnerabilityAssessment(
            assessment_id=assessment_id,
            sector=sector,
            assessment_date=assessment_date,
            overall_risk_score=overall_risk_score,
            vulnerability_count=total_vulnerabilities,
            critical_vulnerabilities=critical_count,
            high_vulnerabilities=high_count,
            medium_vulnerabilities=medium_count,
            low_vulnerabilities=low_count,
            top_vulnerabilities=vulnerabilities,
            sector_profile=sector_profile,
            recommendations=recommendations,
            next_assessment_date=assessment_date + timedelta(days=30)
        )


    def _create_vulnerability_from_template(self, sector: IndustrySector, 
                                          template: Dict[str, Any], index: int) -> SectorVulnerability:
        """Create a sector vulnerability from a template."""
        vulnerability_id = f"VULN_{sector.value}_{index:03d}"
        
        # Add some randomization to make it realistic
        likelihood_modifier = (index * 7) % 20 - 10  # -10 to +10
        impact_modifier = (index * 11) % 15 - 7      # -7 to +7
        
        likelihood = max(10, min(95, template["base_likelihood"] + likelihood_modifier))
        impact = max(10, min(95, template["base_impact"] + impact_modifier))
        risk_score = (likelihood * impact) / 100
        
        return SectorVulnerability(
            vulnerability_id=vulnerability_id,
            sector=sector,
            category=template["category"],
            title=template["title"],
            description=template["description"],
            severity=template["base_severity"],
            likelihood=likelihood,
            impact_score=impact,
            risk_score=risk_score,
            affected_regions=template["affected_regions"],
            critical_components=template["critical_components"],
            dependencies=[f"Dependency_{i}" for i in range((index % 3) + 1)],
            mitigation_strategies=[f"Strategy_{i}" for i in range((index % 4) + 1)],
            time_horizon_days=30 + (index * 15) % 180,
            confidence_level=75 + (index * 5) % 20,
            last_assessed=datetime.utcnow() - timedelta(hours=index * 2)
        )


    def _generate_sector_recommendations(self, sector: IndustrySector, 
                                       vulnerabilities: List[SectorVulnerability]) -> List[str]:
        """Generate sector-specific recommendations based on vulnerabilities."""
        recommendations = []
        
        # Critical vulnerability recommendations
        critical_vulns = [v for v in vulnerabilities if v.severity == SeverityLevel.CRITICAL]
        if critical_vulns:
            recommendations.append(f"Address {len(critical_vulns)} critical vulnerabilities immediately")
        
        # Sector-specific recommendations
        if sector == IndustrySector.TECHNOLOGY:
            recommendations.extend([
                "Diversify semiconductor supplier base across multiple regions",
                "Implement robust cybersecurity frameworks for supply chain",
                "Develop strategic stockpiles for critical components"
            ])
        elif sector == IndustrySector.AUTOMOTIVE:
            recommendations.extend([
                "Secure long-term contracts for automotive-grade semiconductors",
                "Accelerate vertical integration of critical components",
                "Build resilience in battery supply chain"
            ])
        elif sector == IndustrySector.HEALTHCARE:
            recommendations.extend([
                "Implement distributed manufacturing for critical medicines",
                "Strengthen regulatory compliance across global operations",
                "Build pandemic response capabilities"
            ])
        
        return recommendations


    async def _analyze_cross_sector_impacts(self, trigger_sector: IndustrySector, 
                                          scenario: str) -> List[CrossSectorImpact]:
        """Analyze cross-sector impact propagation."""
        # Filter impacts based on trigger sector
        relevant_impacts = [
            impact for impact in self.cross_sector_impacts 
            if impact.source_sector == trigger_sector
        ]
        
        # Add scenario-specific impacts
        if scenario == "supply_disruption":
            # Add additional supply chain related impacts
            pass
        elif scenario == "cyber_attack":
            # Add cyber security related impacts
            pass
        
        return relevant_impacts


    async def _analyze_vulnerability_trends(self, sector: IndustrySector, 
                                          time_period_days: int) -> Dict[str, Any]:
        """Analyze vulnerability trends over time."""
        # This would typically analyze historical data
        # For now, return mock trend analysis
        
        return {
            "sector": sector.value,
            "time_period_days": time_period_days,
            "trend_direction": "increasing",
            "trend_strength": 0.15,
            "key_drivers": [
                "Increased geopolitical tensions",
                "Growing supply chain complexity",
                "Cyber threat evolution"
            ],
            "emerging_vulnerabilities": [
                "Quantum computing threats",
                "Climate change impacts",
                "Regulatory fragmentation"
            ],
            "vulnerability_timeline": [
                {"date": (datetime.utcnow() - timedelta(days=i*10)).isoformat(), 
                 "risk_score": 65 + (i * 2) + ((i * 7) % 15)}
                for i in range(int(time_period_days / 10))
            ]
        }


    def _generate_sector_comparison(self, assessments: Dict[str, VulnerabilityAssessment]) -> Dict[str, Any]:
        """Generate comparative analysis across sectors."""
        comparison = {
            "comparison_date": datetime.utcnow().isoformat(),
            "sectors_analyzed": list(assessments.keys()),
            "sector_rankings": [],
            "risk_distribution": {},
            "common_vulnerabilities": [],
            "sector_interdependencies": [],
            "recommendations": []
        }
        
        # Rank sectors by overall risk
        sector_risks = [(sector, assessment.overall_risk_score) 
                       for sector, assessment in assessments.items()]
        sector_risks.sort(key=lambda x: x[1], reverse=True)
        comparison["sector_rankings"] = sector_risks
        
        # Analyze risk distribution
        for sector, assessment in assessments.items():
            comparison["risk_distribution"][sector] = {
                "critical": assessment.critical_vulnerabilities,
                "high": assessment.high_vulnerabilities,
                "medium": assessment.medium_vulnerabilities,
                "low": assessment.low_vulnerabilities,
                "overall_score": assessment.overall_risk_score
            }
        
        return comparison


    def _serialize_assessment(self, assessment: VulnerabilityAssessment) -> Dict[str, Any]:
        """Serialize assessment for caching."""
        data = asdict(assessment)
        data['sector'] = assessment.sector.value
        data['assessment_date'] = assessment.assessment_date.isoformat()
        data['next_assessment_date'] = assessment.next_assessment_date.isoformat()
        
        # Serialize vulnerabilities
        serialized_vulns = []
        for vuln in assessment.top_vulnerabilities:
            vuln_dict = asdict(vuln)
            vuln_dict['sector'] = vuln.sector.value
            vuln_dict['category'] = vuln.category.value
            vuln_dict['severity'] = vuln.severity.value
            vuln_dict['last_assessed'] = vuln.last_assessed.isoformat()
            serialized_vulns.append(vuln_dict)
        data['top_vulnerabilities'] = serialized_vulns
        
        # Serialize sector profile
        profile_dict = asdict(assessment.sector_profile)
        profile_dict['sector'] = assessment.sector_profile.sector.value
        data['sector_profile'] = profile_dict
        
        return data


# Singleton instance
_sector_vulnerability_assessment = None

def get_sector_vulnerability_assessment() -> SectorVulnerabilityAssessment:
    """Get singleton sector vulnerability assessment instance."""
    global _sector_vulnerability_assessment
    if _sector_vulnerability_assessment is None:
        _sector_vulnerability_assessment = SectorVulnerabilityAssessment()
    return _sector_vulnerability_assessment